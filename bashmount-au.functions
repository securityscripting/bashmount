#. /etc/bashmount-au.conf

# Set filemanager command to use when performing the "open" command. The mount
# point is passed as the first argument. The default is to open the directory
# within your terminal.

# Uncomment this example to launch a graphical file manager.
filemanager() {
   /usr/bin/nautilus "$1" & >/dev/null 2>&1
}

# Uncomment this example to launch midnight commander in a new window.
#filemanager() {
#   /usr/bin/uxterm -wf -e /usr/bin/mc "$1" & >/dev/null 2>&1
#}

# Function to perform a second unique authentication.
second_auth () {
   read -r -e -p "Enter witness username: " witness 
   
   grep -E -w "${witness}" /etc/shadow >> /dev/null
   if [[ "$?" != "0" ]];then
      error "Invalid username"
      pass=false
      
   elif [[ "${SUDO_USER}" == "${witness}" ]]; then
     error "The witness must be a different user"
     pass=false
   
   else

    attempts=0
      until [[ "${attempts}" -ge 3 ]]; do
      read -r -s -p "Enter the password of witness: " pw
        	export pw
		
        	pw_hash=`grep -E -w "${witness}" /etc/shadow | cut -d: -f2`
        	export ALGO=`echo "${pw_hash}" | cut -d'$' -f2`
        	export SALT=`echo "${pw_hash}" | cut -d'$' -f3`
        	gen_hash=$(perl -le 'print crypt("$ENV{pw}","\$$ENV{ALGO}\$$ENV{SALT}\$")')
        	if [[ "${gen_hash}" == "${pw_hash}" ]]; then
                	pass=true
                        break
       		else
			pass=false
                	error "Invalid username-password combination"
                            attempts=$[$attempts+1]
                            if [[ "${attempts}" -ge 3 ]]; then
				pass=false
			    fi
        	fi
      done
   fi
  
      if [[ "${pass}" != true ]]; then
        return 1
      fi

}

# Runs custom pre-conditions.
#pre_mount () {
#TODO
#if [[ "${enable_whitelist}" == 'yes' ]]; then
#whitelisting checks not yet implemented
#local -a all=()
#whitelist() 

#all=( $(lsblk -lno NAME) )
#for devname in ${all[@]}; do
  #lsblk -p option not available in rhel6. Doesn't grab /dev dir so adding manually here
  #devname=/dev/"${devname}"
  #for string in ${whitelist[@]}; do
    #PARTLABEL column not available on rhel6 version
    #output 2>/dev/null or lsblk shows complains
       #lsblk -dPno UUID "${devname}" | grep -E "${string}" > /dev/null #2>&1 Comment out error notification
    #if [[ $? == 0 ]]; then 
     # || continue 2
      #continue 2
    #else
      #return 1
    #fi
  #done
#done
 
#fi
#}

ask_questions() {
 if [[ "${enable_questions}" == 'yes' ]]; then
   read -p "Enter the source of the data: " source
   echo "${date_fmt}:$source:media source" >> "${logfile}"
   echo "${date_fmt}:$(hostname):media destination" >> "${logfile}"
   read -p "Enter the classification of the data: " classification
   echo "${date_fmt}:$classification:media classification" >> "${logfile}"
 else
   return 0
 fi 
}

mount_failed () {
  if [[ "${enable_logging}" == 'yes' ]]; then
    echo "${date_fmt}:${SUDO_USER}:mount failed" >> "${logfile}"
  fi
    return 1
}

# Customize the command used for mounting. You should not need to change this.
# Open /usr/bin/bashmount in a text editor to see the default commands.
# The device path /dev/sdx is passed as first argument.
#
# This example creates mountpoint directories and sets permissions so only the user running the script has access.
mount_command() {
ask_questions
 #if [[ "${run_pre_mount}" ]]; then
   #if ! pre_mount "${dir}"; then
      #mount_failed
   #else
     if [[ "${tpi}" == 'yes' ]]; then
       if ! second_auth; then
          mount_failed
       else
          #don't let anyone other than the user have access
          if [ ! -d /mnt/"${SUDO_USER}" ]; then
             mkdir /mnt/"${SUDO_USER}"
          fi
             chmod 700 /mnt/"${SUDO_USER}"
             chown $SUDO_USER /mnt/"${SUDO_USER}"
  
          if [ ! -d "/mnt/"${SUDO_USER}"/${1##*/}" ]; then
             mkdir /mnt/"${SUDO_USER}"/${1##*/}
          fi 
             dir=/mnt/"${SUDO_USER}"/${1##*/}
             echo
             mount ${mount_options} "${1}" "${dir}"
       fi
     fi
   #fi
 #fi  
}

#virus_scan () {
#    msg "scanning $mountpoint..."
#    "${antivirus_scanner_exec}" "${1}"
#}

#unmount_command() {
#   umount "$1"
#}

# Set custom commands. Set "customX_show" to '0' to disable or '1' to enable.
# If enabled, the custom commands will be shown in the device sub-menu. The
# description and command functions can be set to anything you desire. The
# device name (e.g. /dev/sdb1) is passed as the first and only argument.
# A maximum of 3 custom actions are configurable.

action_burn() {
ask_questions
if [[ "${tpi}" == 'yes' ]]; then
  if second_auth; then
     if [[ "${enable_logging}" == 'yes' ]]; then
        date_k3b_fmt="$(date +%F-%H-%M-%S)"
        k3b_file="/var/log/k3b-burn/${date_k3b_fmt}-k3b.log"
        echo "${date_fmt}:$SUDO_USER:starting k3b" >> "${logfile}" 
        #echo "================ "${date_k3b_fmt}" ====================" >> "${k3b_file}"
        #info_label="$(info_fslabel "${1}")"
        #echo "label: ${info_label}" >> "${k3b_file}"
        #run a watch where k3b temporarily stores a file of items selected to be burned. Copies the file to another location before k3b removes it.
        nohup /usr/bin/logk3b.sh "${SUDO_USER}" "${k3b_file}" </dev/null >/dev/null 2>&1 &
        logk3b_process="$(pgrep logk3b.sh)"
        runuser -l $SUDO_USER -c 'k3b >/dev/null 2>/dev/null'
     else
        runuser -l $SUDO_USER -c 'k3b >/dev/null 2>/dev/null'
     fi
  else
    return 1
  fi
else
  runuser -l $SUDO_USER -c 'k3b >/dev/null 2>/dev/null'
fi
}

#custom4_command() {
#     
#}


#custom5_command() {
#scan_exec=/opt/Symantec/symantec_antivirus/sav
#if [ ! -x scan_exec ]; then
#   error "scanner not available"
#else
   #mountpoint="$(findmnt -no TARGET "${1}")"
   #virus_scan "${mountpoint}"
#fi
#}


#custom6_command() {
#
#}

# Set custom commands to be run automatically after mounting or unmounting.
# The device name (e.g. /dev/sdb1) is passed as the first and only argument.
# post_mount is run immediately after a successful mount operation, and
# post_unmount is run immediately after a successful unmount operation.


# This example starts a script which audits the mountpoint and user home directory to catch file transfers and logs the media information.

post_mount () {
  if [[ "${enable_logging}" == 'yes' ]]; then
     local -a watchdir=
     watchdir="${watch_directories}"
     mountpoint="$(findmnt -no TARGET "${1}")"
     user_home="$(echo "${USERNAME}" | cut -d = -f 2)"
     echo "All data transfers are being audited to/from /home/${user_home}, ${mountpoint} and ${watchdir}"
     nohup $mediawatch "${mountpoint}" "/home/${user_home}" "${watchdir}" "${logfile}" </dev/null >/dev/null 2>&1 &
     mediawatch_process="$(pgrep $mediawatch)"
     echo "${date_fmt}:${SUDO_USER}:${witness}:mount successful" >> "${logfile}"
     mount_info="$(lsblk -o NAME,FSTYPE,MOUNTPOINT,SIZE,LABEL,UUID "${1}")"
     echo "${mount_info}" >> "${logfile}" 
  fi


#needs work, commenting out
# Automatically virus scan optical media. Comment out if desired. Symantec scanner used as an example. Replace with system scanning command.
#info_type=$(info_type "${1}")
#if [[ "${info_type}" == 'rom' ]]; then
   #virus_scan "${mountpoint}"
#fi
}


# This example will record the media information in the log file and kills then stops the media auditing.
post_unmount() {

   echo "${date_fmt}:$SUDO_USER:unmount successful" >> "${logfile}"
   mount_info="$(lsblk -o NAME,FSTYPE,MOUNTPOINT,SIZE,LABEL,UUID "${1}")"
   echo "${mount_info}" >> "${logfile}" 
#needs work!
if [[ "${enable_logging}" == 'yes' ]]; then
   pkill $mediawatch_process
   pkill $logk3b_process
fi
}


#This example notifies the user of failed prechecks and then exits. It also loads the usb kernel module to allow usb devices if previously disabled in /etc/modprobe.d 
pre_init() {

#=================================================
if [[ "${automount_enable}" == 'yes' ]]; then
   autorun_check="$(gconftool-2 --direct --config-source xml:read:/etc/gconf/gconf.xml.mandatory --get /apps/nautilus/preferences/media_autorun_never)"
   if [[ "${autorun_check}" != true ]]; then
      error "gnome autorun should be disabled"
      init=false
   fi

   automount_check="$(gconftool-2 --direct --config-source xml:read:/etc/gconf/gconf.xml.mandatory --get /apps/nautilus/preferences/media_automount_open)"
   if [[ "${automount_check}" != false ]]; then
     error "gnome automount should be disabled"
     init=false
   fi

   service autofs status >/dev/null
   if [[ $? = 0 ]]; then
      error "autofs service should be disabled" 
      init=false
   fi
fi
#==================================================
 if [[ "${enable_logging}" == 'yes' ]]; then
   #check for existence of log file
   if [[ ! -f "${logfile}" ]]; then
      error "log file cannot be found"
      init=false
   fi
   
   #check for inotify-tools rpm
   rpm -qa | grep inotify-tools >> /dev/null
   if [[ $? != 0 ]];then
      error "inotify executable cannot be found. Install inotify-tools" >> "${logfile}"
      init=false
   fi 
 
   #check for existence of custom executable
   if [[ ! -f "${mediawatch}" ]]; then
      error "mediawatch executable cannot be found. Install mediawatch.sh"
      init=false
   fi 
 fi
#=================================================
   # Optional group check or just set sudo for executable to restrict. You can probably leave this commented out.
   #authorized_group=dta
   #check for automount disabled. kde?
   #getent group $authorized_group | grep "$SUDO_USER"
   #if [ $? != 0 ];then
      #echo "$SUDO_USER is not in the $authorized_group"
      #exit 1
   #fi
#==================================================
   # Warn or exit if script is run directly by root.
  if [[ "${sudo_required}" == 'yes' ]]; then
     if [[ "${SUDO_USER}" = '' ]]; then
        error "$0 should be run with sudo"
        init=false
     fi
  fi
#=================================================
   #warn if k3b is not installed
   rpm -qa | grep k3b >/dev/null
   if [[ $? != 0 ]]; then
      error "k3b is not installed. You will not be able to burn optical media" 
   fi
#==================================================
   #exit if any init checks are false
   if [[ "${init}" == "false" ]]; then
     error "exiting..."
     exit 1
   else
     echo "=============================================" >> "${logfile}"
     # Enables usb driver module
     if [[ "${load_usb_module}" == 'yes' ]]; then
       insmod /lib/modules/"$(uname -r)"/kernel/drivers/usb/storage/usb-storage.ko 2>/dev/null
       if [ $? = 0 ]; then
          echo "${date_fmt}:usb-storage.ko:module inserted successfully" >> "${logfile}"
       else
          error "usb module already inserted or failed"
          echo  "${date_fmt}:usb-storage.ko:failed module insert" >> "${logfile}"
       fi
       #give a few seconds to recognize
       sleep 2
       return 0
     fi
   fi
}


#This example removes the usb kernel module before quitting and gives an error if unable
post_init() {
if [[ "${load_usb_module}" == 'yes' ]]; then
  rmmod /lib/modules/"$(uname -r)"/kernel/drivers/usb/storage/usb-storage.ko 
  if [[ $? != 0 ]]; then
    echo "${date_fmt}:usb-storage.ko:failed to remove module" >> "${logfile}"
    error "Make sure to unmount device or contact System Administrator" 
    enter_to_continue
    return 1
  else
    echo "${date_fmt}:usb-storage.ko:module removed successfully" >> "${logfile}"
  fi
fi

}


