#
# bashmount.conf
#

# Place in /etc/bashmount.conf for system wide configuration.
# Place in ~/.config/bashmount/config for per-user configuration.
# XDG_CONFIG_HOME is respected if it has been set.

# Optional two person integrity requirement. Set '1' to enable.
tpi='1'

# Set the date formate for log file 
date_fmt="$(date +%D-%H-%M-%S)"

# Set the antivirus scanning command if available
antivirus_scanner_exec="/opt/Symantec/symantec_antivirus/sav manualscan -s"

# Log file
logfile=/var/log/dta.log

# Set whether to or not to use udisksctl. The default is to autodetect whether
# it is available. This can be '0', '1', or 'auto'.
udisks='0'

# Set which sections to show in the output. These can be '0' or '1'.
# Bear in mind that hiding internal devices will also hide all luks volumes,
# regardless of whether they are from a removable device. You may be better off
# blacklisting internal volumes that you don't want to see.
#show_internal='1'
#show_removable='1'
#show_optical='1'
#show_commands='1'

# When device names are really long, we abbreviate the output slightly.
# Set whether to show the full device name regardless of the length.
# This can be '0' or '1'.
#show_full_device_names='0'

# Set whether to colourize the output. This can be '0' or '1'.
#colourize='1'

# Set default mount options.
default_mount_options="--options nosuid,noexec,noatime,uid=${SUDO_UID}"

# Set devices to blacklist. Any device whose "lsblk -P" output contains a string
# listed here will be hidden. The following key-value-pairs are printed:
# lsblk -dPno NAME,TYPE,FSTYPE,LABEL,MOUNTPOINT,PARTLABEL [device_name]
# The strings are matched using "grep -E".
#blacklist=()

###
### This example will match any device with "Photosmart" in any field.
### blacklist=( 'Photosmart' )
###
### This example will match the device found at /dev/sda1.
 blacklist=( 'NAME="sda"' )
###
### This example will match /dev/sda1, /dev/sda2 and /dev/sda3.
 blacklist+=( 'NAME="sda[1-9]"' )
###
### This example matches several different devices. Note that the array can be
### split over multiple lines for convenience.
### blacklist=( 'FSTYPE="ext3"' )
### blacklist+=( 'LABEL="secret"' 'PARTLABEL="secret"' )
### blacklist+=( 'MOUNTPOINT="/"' )
###

# Set filemanager command to use when performing the "open" command. The mount
# point is passed as the first argument. The default is to open the directory
# within your terminal.

# Uncomment this example to launch a graphical file manager.
filemanager() {
   /usr/bin/nautilus "$1" & >/dev/null 2>&1
}

# Uncomment this example to launch midnight commander in a new window.
#filemanager() {
#   /usr/bin/uxterm -wf -e /usr/bin/mc "$1" & >/dev/null 2>&1
#}

# Set "run_pre_mount" to '0' to disable or '1' to enable.
run_pre_mount='1'
# Runs custom pre-conditions such as log file and logging executable existence.
pre_mount () {

#check for existence of log file
if [[ ! -f "${logfile}" ]]; then
  error "log file cannot be found"
  exit 1
fi

rpm -qa | grep inotify-tools >> /dev/null
if [[ $? != 0 ]];then
  echo "inotify executable cannot be found. Install inotify-tools..exiting" >> "${logfile}"
  return 1
fi 

#set custom executable
mediawatch=/usr/bin/mediawatch.sh
#check for existence of custom executable
if [[ ! -f "${mediawatch}" ]]; then
  error "mediawatch executable cannot be found. Install mediawatch.sh..exiting"
  exit 1
fi 

if (( tpi )); then
   read -r -e -p "Enter witness username: " witness 
   
   grep -E -w "${witness}" /etc/shadow >> /dev/null
   if [[ "$?" != "0" ]];then
      error "Invalid username"
      pass=false
      
   elif [[ "${SUDO_USER}" == "${witness}" ]]; then
     error "The witness must be a different user"
     pass=false
   
   else

    attempts=0
      until [[ "${attempts}" -ge 3 ]]; do
      read -r -s -p "Enter the password of witness: " pw
        	export pw
		
        	pw_hash=`grep -E -w "${witness}" /etc/shadow | cut -d: -f2`
        	export ALGO=`echo "${pw_hash}" | cut -d'$' -f2`
        	export SALT=`echo "${pw_hash}" | cut -d'$' -f3`
        	gen_hash=$(perl -le 'print crypt("$ENV{pw}","\$$ENV{ALGO}\$$ENV{SALT}\$")')
        	if [[ "${gen_hash}" == "${pw_hash}" ]]; then
                	pass=true
                        break
       		else
			pass=false
                	error "Invalid username-password combination"
                            attempts=$[$attempts+1]
                            if [[ "${attempts}" -ge 3 ]]; then
				pass=false
			    fi
        	fi
     done
    fi
  
 if [[ "${pass}" != true ]]; then
   return 1
 fi
fi
   echo
   #ask questions to log. NIST 800-53A AC-4 Assured File Transfer
   #read -p "Enter the source of the data: " source
   #echo "${date_fmt}:$source:media source" >> $logfile
   #echo "${date_fmt}:$(hostname):media destination" >> $logfile
   #read -p "Enter the classification of the data: " classification
   #echo "${date_fmt}:$classification:media classification" >> $logfile
   
}

# Customize the command used for mounting. You should not need to change this.
# Open /usr/bin/bashmount in a text editor to see the default commands.
# The device path /dev/sdx is passed as first argument.
#
# This example creates mountpoint directories and sets permissions so only the user running the script has access.
mount_command() {
   #don't let anyone other than the user have access
   if [ ! -d /mnt/"${SUDO_USER}" ]; then
      mkdir /mnt/"${SUDO_USER}"
   fi
      chmod 700 /mnt/"${SUDO_USER}"
      chown $SUDO_USER /mnt/"${SUDO_USER}"
  
   if [ ! -d "/mnt/"${SUDO_USER}"/${1##*/}" ]; then
     mkdir /mnt/"${SUDO_USER}"/${1##*/}
   fi 
     dir=/mnt/"${SUDO_USER}"/${1##*/}
      if [ run_pre_mount ]; then
        if pre_mount "${dir}"; then
          echo
          mount ${mount_options} "${1}" "${dir}"
        else
          echo "${date_fmt}:${SUDO_USER}:mount failed" >> $logfile
          return 1
        fi
      fi  
}

virus_scan () {
      msg "scanning $mountpoint..."
     "${antivirus_scanner_exec}" "${1}"
}

#unmount_command() {
#   umount "$1"
#}

# Set custom commands. Set "customX_show" to '0' to disable or '1' to enable.
# If enabled, the custom commands will be shown in the device sub-menu. The
# description and command functions can be set to anything you desire. The
# device name (e.g. /dev/sdb1) is passed as the first and only argument.
# A maximum of 3 custom actions are configurable.

#custom4_show='1'
#custom4_desc='burn data disk'
#custom4_command() {
#     mkisofs -r -R -J -l -L /home/user1 | cdrecord dev=0,4,0 -v --eject speed=4 -
#}

custom5_show='1'
custom5_desc='virusscan'
custom5_command() {
if [ ! -x virus_scan_exec ]; then
   error "scanner not available"
else
   mountpoint="$(findmnt -no TARGET "${1}")"
   virus_scan "${mountpoint}"
fi
}

#custom6_show='0'
#custom6_desc='changeme'
#custom6_command() {
#
#}

# Set custom commands to be run automatically after mounting or unmounting.
# This is useful for spinning down a hard drive after unmounting it. The
# device name (e.g. /dev/sdb1) is passed as the first and only argument.
# Uncomment the examples below, or modify them to pass any arbitrary commands.
# post_mount is run immediately after a successful mount operation, and
# post_unmount is run immediately after a successful unmount operation.


# Set "run_post_mount" to '0' to disable or '1' to enable.
run_post_mount='1'
# This example starts a script which audits the mountpoint and user home directory to catch file transfers and logs the media information.
post_mount () {
  mountpoint="$(findmnt -no TARGET "${1}")"
  user_home="$(echo "${USERNAME}" | cut -d = -f 2)"
  echo "All data transfers are being audited to/from /home/${user_home} and ${mountpoint}"
  nohup $mediawatch "${mountpoint}" "/home/${user_home}" "${logfile}" </dev/null >/dev/null 2>&1 &
  echo "${date_fmt}:${SUDO_USER}:${witness}:mount successful" >> $logfile
  mount_info="$(lsblk -o NAME,FSTYPE,MOUNTPOINT,SIZE,LABEL,UUID "${1}")"
  echo "${mount_info}" >> $logfile 


# Automatically virus scan optical media. Comment out if desired. Symantec scanner used as an example. Replace with system scanning command.
info_type=$(info_type "${1}")
if [[ "${info_type}" == 'rom' ]]; then
   virus_scan "${mountpoint}"
fi
}

# Set "run_post_unmount" to '0' to disable or '1' to enable.
run_post_unmount='1'
# This example will record the media information in the log file and kills then stops the media auditing.
post_unmount() {

   echo "${date_fmt}:$SUDO_USER:unmount successful" >> $logfile
   mount_info="$(lsblk -o NAME,FSTYPE,MOUNTPOINT,SIZE,LABEL,UUID "${1}")"
   echo "${mount_info}" >> $logfile 
#needs work!
   kill_processes="$(pidof inotifywait)"
   for kill_process in "$kill_processes"; do
     #echo $kill_process
     kill -9 $kill_process >/dev/null 2>/dev/null
   done
}

#run custom pre-initialization scripts. Set '0' to disable or '1' to enable 
run_pre_init='1'
#This example loads the usb kernel module to allow usb devices if previously disabled in /etc/modprobe.d 
pre_init() {

# Set to '1' to check and stop script if automount and autorun is NOT disabled...automount would bypass the custom mount script.
automount_disable='1'
if [[ $automount_disable ]]; then

  autorun_check="$(gconftool-2 --direct --config-source xml:read:/etc/gconf/gconf.xml.mandatory --get /apps/nautilus/preferences/media_autorun_never)"
   if [[ "${autorun_check}" != true ]]; then
      error "gnome autorun should be disabled"
      result=false
   fi

  automount_check="$(gconftool-2 --direct --config-source xml:read:/etc/gconf/gconf.xml.mandatory --get /apps/nautilus/preferences/media_automount_open)"
   if [[ "${automount_check}" != false ]]; then
      error "gnome automount should be disabled"
      result=false
   fi

 service autofs status >/dev/null
  if [[ $? = 0 ]]; then
    error "autofs service should be disabled" 
    result=false
  fi

  if [[ "${result}" == "false" ]]; then
     exit 1
  fi
fi

# Optional group check or just set sudo for executable to restrict. You can probably leave this commented out.
   #authorized_group=dta
   #check for automount disabled. kde?
   #getent group $authorized_group | grep "$SUDO_USER"
   #if [ $? != 0 ];then
      #echo "$SUDO_USER is not in the $authorized_group"
      #exit 1
   #fi
#

   # Warn or exit if script is run directly by root.
   if [[ "${SUDO_USER}" = '' ]]; then
      error "$0 should be run with sudo"
      exit 1
   fi

   echo "=============================================" >> $logfile
   # Enables usb driver module
   insmod /lib/modules/"$(uname -r)"/kernel/drivers/usb/storage/usb-storage.ko 2>/dev/null
   if [ $? = 0 ]; then
      echo "${date_fmt}:usb-storage.ko:module inserted successfully" >> $logfile
   else
      echo "${date_fmt}:usb-storage.ko:failed module insert" >> $logfile
   fi
   #give a few seconds to recognize
   sleep 2
   return 0
}

# Set to '1' to run post_init function before exiting script.
run_post_init='1'
#This example removes the usb kernel module before quitting and gives an error if unable
post_init() {
  rmmod /lib/modules/"$(uname -r)"/kernel/drivers/usb/storage/usb-storage.ko 
  if [[ $? != 0 ]]; then
    echo "${date_fmt}:usb-storage.ko:failed to remove module" >> $logfile
    error "Make sure to unmount device or contact System Administrator" 
    enter_to_continue
    return 1
  else
    echo "${date_fmt}:usb-storage.ko:module removed successfully" >> $logfile
  fi
}


