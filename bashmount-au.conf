#
# bashmount.conf
#

# Place in /etc/bashmount.conf for system wide configuration.
# Place in ~/.config/bashmount/config for per-user configuration.
# XDG_CONFIG_HOME is respected if it has been set.

# Optional two person integrity requirement. Set '1' to enable.
tpi='1'

# Set the date formate for log file 
date_fmt="$(date +%D-%H-%M-%S)"

# Log file
logfile=/var/log/dta.log

# Set whether to or not to use udisksctl. The default is to autodetect whether
# it is available. This can be '0', '1', or 'auto'.
udisks='0'

# Set which sections to show in the output. These can be '0' or '1'.
# Bear in mind that hiding internal devices will also hide all luks volumes,
# regardless of whether they are from a removable device. You may be better off
# blacklisting internal volumes that you don't want to see.
#show_internal='1'
#show_removable='1'
#show_optical='1'
#show_commands='1'

# When device names are really long, we abbreviate the output slightly.
# Set whether to show the full device name regardless of the length.
# This can be '0' or '1'.
#show_full_device_names='0'

# Set whether to colourize the output. This can be '0' or '1'.
#colourize='1'

# Set default mount options.
default_mount_options='--options nosuid,noexec,noatime,nouser'

# Set devices to blacklist. Any device whose "lsblk -P" output contains a string
# listed here will be hidden. The following key-value-pairs are printed:
# lsblk -dPno NAME,TYPE,FSTYPE,LABEL,MOUNTPOINT,PARTLABEL [device_name]
# The strings are matched using "grep -E".
#blacklist=()

###
### This example will match any device with "Photosmart" in any field.
### blacklist=( 'Photosmart' )
###
### This example will match the device found at /dev/sda1.
 blacklist=( 'NAME="sda"' )
###
### This example will match /dev/sda1, /dev/sda2 and /dev/sda3.
 blacklist+=( 'NAME="sda[1-9]"' )
###
### This example matches several different devices. Note that the array can be
### split over multiple lines for convenience.
### blacklist=( 'FSTYPE="ext3"' )
### blacklist+=( 'LABEL="secret"' 'PARTLABEL="secret"' )
### blacklist+=( 'MOUNTPOINT="/"' )
###

# Set filemanager command to use when performing the "open" command. The mount
# point is passed as the first argument. The default is to open the directory
# within your terminal.

# Uncomment this example to launch a graphical file manager.
filemanager() {
   /usr/bin/nautilus "$1" & >/dev/null 2>&1
}

# Uncomment this example to launch midnight commander in a new window.
#filemanager() {
#   /usr/bin/uxterm -wf -e /usr/bin/mc "$1" & >/dev/null 2>&1
#}

# Set "run_pre_mount" to '0' to disable or '1' to enable.
run_pre_mount='1'
# Runs custom pre-conditions such as log file and logging executable existence.
pre_mount () {

#check for existence of log file
if [[ ! -f "${logfile}" ]]; then
  error "log file cannot be found"
  exit 1
fi

#check for inotifywait installation
rpm -qa | grep inotifywait >> /dev/null
if [[ $? = 0 ]];then
  error "inotify executable cannot be found. Install inotify-tools..exiting"
  exit 1
fi

#set custom executable
mediawatch=/usr/bin/mediawatch.sh
#check for existence of custom executable
if [[ ! -f "${mediawatch}" ]]; then
  error "mediawatch executable cannot be found. Install mediawatch.sh..exiting"
  exit 1
fi 

if (( tpi )); then
   read -r -e -p "Enter witness username: " witness 
   
   grep -E -w "${witness}" /etc/shadow >> /dev/null
   if [[ "$?" != "0" ]];then
      error "Invalid username"
      pass=false
      
   elif [[ "${SUDO_USER}" == "${witness}" ]]; then
     error "The witness must be a different user"
     pass=false
   
   else

    attempts=0
      until [[ "${attempts}" -ge 3 ]]; do
      read -r -s -p "Enter the password of witness: " pw
        	export pw
		
        	pw_hash=`grep -E -w "${witness}" /etc/shadow | cut -d: -f2`
        	export ALGO=`echo "${pw_hash}" | cut -d'$' -f2`
        	export SALT=`echo "${pw_hash}" | cut -d'$' -f3`
        	gen_hash=$(perl -le 'print crypt("$ENV{pw}","\$$ENV{ALGO}\$$ENV{SALT}\$")')
        	if [[ "${gen_hash}" == "${pw_hash}" ]]; then
                	pass=true
                        break
       		else
			pass=false
                	error "Invalid username-password combination"
                            attempts=$[$attempts+1]
                            if [[ "${attempts}" -ge 3 ]]; then
				pass=false
			    fi
        	fi
     done
    fi
  
 if [[ "${pass}" != true ]]; then
   return 1
 fi
fi


}

# Customize the command used for mounting. You should not need to change this.
# Open /usr/bin/bashmount in a text editor to see the default commands.
# The device path /dev/sdx is passed as first argument.
#
# This example creates mountpoint directories and sets permissions so only the user running the script has access.
mount_command() {
   #don't let anyone other than the user have access
   if [ ! -d /mnt/"${USERNAME}" ]; then
      mkdir /mnt/"${USERNAME}"
   fi
      chmod 700 /mnt/"${USERNAME}"
      chown $USERNAME /mnt/"${USERNAME}"
  
   if [ ! -d "/mnt/"${USERNAME}"/${1##*/}" ]; then
     mkdir /mnt/"${USERNAME}"/${1##*/}
   fi 
     dir=/mnt/"${USERNAME}"/${1##*/}
      if [ $run_pre_mount ]; then
        if pre_mount "${dir}"; then
          echo
          mount ${mount_options} "${1}" "${dir}"
        else
          return 1
        fi
      fi  
}

#unmount_command() {
#   umount "$1"
#}

# Set custom commands. Set "customX_show" to '0' to disable or '1' to enable.
# If enabled, the custom commands will be shown in the device sub-menu. The
# description and command functions can be set to anything you desire. The
# device name (e.g. /dev/sdb1) is passed as the first and only argument.
# A maximum of 3 custom actions are configurable.

#custom4_show='1'
#custom4_desc='burn data disk'
#custom4_command() {
#    #mount --options remount,ro "$1" "/mnt/${1##*/}"        #
#     mkisofs -r -R -J -l -L /home/user1 | cdrecord dev=0,4,0 -v --eject speed=4 -
#}

#custom5_show='0'
#custom5_desc='changeme'
#custom5_command() {
#
#}

#custom6_show='0'
#custom6_desc='changeme'
#custom6_command() {
#
#}

# Set custom commands to be run automatically after mounting or unmounting.
# This is useful for spinning down a hard drive after unmounting it. The
# device name (e.g. /dev/sdb1) is passed as the first and only argument.
# Uncomment the examples below, or modify them to pass any arbitrary commands.
# post_mount is run immediately after a successful mount operation, and
# post_unmount is run immediately after a successful unmount operation.


# Set "run_post_mount" to '0' to disable or '1' to enable.
run_post_mount='1'
# This example starts a script which audits the mountpoint and user home directory to catch file transfers and logs the media information.
post_mount () {
  mountpoint="$(findmnt -no TARGET "${1}")"
  echo "All data transfers are being audited to/from $mountpoint"
  user_home="$(echo "${USERNAME}" | cut -d = -f 2)"
  nohup $mediawatch "${mountpoint}" "/home/${user_home}" "${logfile}" </dev/null >/dev/null 2>&1 &
  echo "${date_fmt}:${USERNAME}:${witness}:file system mounted" >> $logfile
  mount_info="$(lsblk -o NAME,FSTYPE,MOUNTPOINT,SIZE,LABEL,UUID "${1}")"
  echo "${mount_info}" >> $logfile 


# Automatically virus scan optical media. Comment out if desired. Symantec scanner used as an example. Replace with system scanning command.
antivirus_scanner_exec="/opt/Symantec/symantec_antivirus/sav manualscan -s"
info_type=$(info_type "${1}")
if [[ "${info_type}" == 'rom' ]]; then
  msg "scanning $mountpoint..."
  "${antivirus_scanner_exec}" "${mountpoint}"
fi
}

# Set "run_post_unmount" to '0' to disable or '1' to enable.
run_post_unmount='1'
# This example will record the media information in the log file and kills then stops the media auditing.
post_unmount() {

   echo "${date_fmt}:$USERNAME:$witness:file system unmounted" >> $logfile
   mount_info="$(lsblk -o NAME,FSTYPE,MOUNTPOINT,SIZE,LABEL,UUID "${1}")"
   echo "${mount_info}" >> $logfile 
#needs work!
   kill_processes="$(pidof inotifywait)"
   for kill_process in "$kill_processes"; do
     #echo $kill_process
     kill -9 $kill_process >/dev/null 2>/dev/null
   done
}

#run custom pre-initialization scripts. Set '0' to disable or '1' to enable 
run_pre_init='1'
#This example loads the usb kernel module to allow usb devices if previously disabled in /etc/modprobe.d 
pre_init() {

# Set to '1' to check and stop script if automount and autorun is NOT disabled...automount would bypass the custom mount script.
automount_disable='1'
if [[ $automount_disable ]]; then

  autorun_check="$(gconftool-2 --direct --config-source xml:read:/etc/gconf/gconf.xml.mandatory --get /apps/nautilus/preferences/media_autorun_never)"
   if [[ "${autorun_check}" != true ]]; then
      error "gnome autorun should be disabled"
      result=false
   fi

  automount_check="$(gconftool-2 --direct --config-source xml:read:/etc/gconf/gconf.xml.mandatory --get /apps/nautilus/preferences/media_automount_open)"
   if [[ "${automount_check}" != false ]]; then
      error "gnome automount should be disabled"
      result=false
   fi

 service autofs status >/dev/null
  if [[ $? = 0 ]]; then
    error "autofs service should be disabled" 
    result=false
  fi

  if [[ "${result}" == "false" ]]; then
     exit 1
  fi
fi

# Optional group check or just set sudo for executable to restrict. You can probably leave this commented out.
   #authorized_group=dta
   #check for automount disabled. kde?
   #getent group $authorized_group | grep "$USERNAME"
   #if [ $? != 0 ];then
      #echo "$USERNAME is not in the $authorized_group"
      #exit 1
   #fi
#

   # Warn or exit if script is run directly by root.
   if [[ "${SUDO_USER}" = '' ]]; then
      error "$0 should be run with sudo"
      exit 1
   fi

   # Enables usb driver module
   insmod /lib/modules/"$(uname -r)"/kernel/drivers/usb/storage/usb-storage.ko 2>/dev/null
   #give a few seconds to recognize
   sleep 2
   return 0
}

# Set to '1' to run post_init function before exiting script.
run_post_init='1'
#This example removes the usb kernel module before quitting and gives an error if unable
post_init() {
  rmmod /lib/modules/"$(uname -r)"/kernel/drivers/usb/storage/usb-storage.ko 
  if [[ $? != 0 ]]; then
    echo "${date_fmt}":usb module failed to unload >> $logfile
    error "Make sure to unmount device or contact System Administrator" 
    enter_to_continue
    return 1
  fi
}


